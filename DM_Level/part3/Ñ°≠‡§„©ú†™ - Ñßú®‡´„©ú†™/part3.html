 <html>
<head>
<meta http-equiv="Content-Type"
content="text/html; charset=ISO-8859-7">


<title>
'Ασκηση 4
</title>

</head>

<body>

<body background="sumtextb.jpg" bgcolor="#FFFFFF" text="#000066" link="#3333CC" vlink="#666699" alink="#990099"  >

<h1>
<center>
Πληροφορική & Τηλεπικοινωνίες K25<br>
Ανάπτυξη Λογισμικού<br>
Εαρινό Εξάμηνο 2008<br>
Καθηγητής Γιάννης Ιωαννίδης
</center>
</h1>
<p>

<hr>

<center>

<h1>Μέρος 3ο:  Επίπεδο Λειτουργικότητας Χρήστη</h1>
<h3>(Ημερομηνία Παράδοσης: Τρίτη 17/6/2008, 11:59μμ)</h3>
</center>

<h2><img src="../images/ball-t.gif">Εισαγωγή</h2>

Για την ολοκλήρωση της όλης εργασίας απαιτείται η κατασκευή των
παρακάτω τριών προγραμμάτων:</p>
<ol>
   <li>dbcreate</li>
   <li>dbdestroy</li>
   <li>minirel</li>
</ol>

<h3>1 - dbcreate</h3>

Το πρόγραμμα dbcreate είναι ένα (μικρό) βοήθημα που χρησιμοποιείται
για την δημιουργία νέων βάσεων δεδομένων. </p>

<p><strong>Σύνταξη:</strong>
Η λειτουργία του προγράμματος είναι εξαιρετικά απλή. Αρκεί στην
γραμμή εντολών ο χρήστης να πληκτρολογήσει <em>dbcreate dbName</em>
και το πρόγραμμα δημιουργεί μία νέα βάση δεδομένων με όνομα
<em>dbName</em>.
Η βάση αυτή μπορεί στην συνέχεια να χρησιμοποιηθεί από το πρόγραμμα
<em>minirel</em> ή μπορεί να διαγραφεί με την βοήθεια του
<em>dbdestroy</em>.</p>

<p><strong>Πληροφορίες υλοποίησης:</strong>
Κάθε βάση αποτελείται από ένα σύνολο από σχέσεις και ευρετήρια.
Τα αρχεία αυτά τοποθετούνται μέσα σε ένα φάκελο που έχει το ίδιο όνομα
με την βάση. Επομένως, η δημιουργία μία νέας βάσης με όνομα
<em>dbName</em>, ισοδυναμεί με την δημιουργία ενός νέου φακέλου με όνομα
<em>dbName</em> και την
κατασκευή (μέσα σε αυτόν) των πινάκων που αφορούν τα
μεταδεδομένα (σχέσεις <em>relCat</em>, <em>attrCat</em>, κλπ.)
της βάσης.</p>

<p>Οι σχέσεις θα δημιουργηθούν χρησιμοποιώντας κατάλληλα τις 
συναρτήσεις του επιπέδου HF.
Φυσικά, αν το επιθυμείτε, μπορείτε να δημιουργήσετε και
ευρετήρια με σκοπό την επιτάχυνση της χρήσης των σχέσεων αυτών.</p>

<p>Για τη δημιουργία φακέλων, δεν έχει γίνει καμία πρόβλεψη από το
πρότυπο της C. Για αυτό τον λόγο θα πρέπει να χρησιμοποιήσετε την
<em>mkdir</em> του κελύφους. Για παράδειγμα, για να φτιάξετε τον φάκελο
<em>foo</em>, θα πρέπει να χρησιμοποιήσετε την εντολή
<em>system(&quot;mkdir foo&quot;)</em>.</p>

<p>Σε γενικές γραμμές, η συνάρτηση <em>main()</em> του <em>dbcreate</em>
θα έχει την ακόλουθη μορφή:</p>

<pre>int main(int argc, char* argv[]){
        char command[80];
        char* dbname;

        if(argc!=2){
                printf(&quot;Χρήση: %s dbname \n&quot;,argv[0]);
                return(1);
        }
</pre>

<pre>
	dbname=argv[1];
        sprintf(command,&quot;mkdir %s&quot;,dbname);
        system(command);
        if(!chdir(dbname)){
                printf(&quot;Δεν είναι δυνατή η δημιουργία της βάσης");
                return(2);
        }
        /* Δημιουργία των πινάκων relCat και attrCat με χρήση των 
           συναρτήσεων ΗF_CreateFile  */
        .
        .
        .
        return 0;
}</pre>

<h3>2 - dbdestroy</h3>

Το πρόγραμμα <em>dbdestroy</em> είναι ένα (μικρό) βοήθημα που
χρησιμοποιείται για την διαγραφή βάσεων δεδομένων. </p>

<p><strong>Σύνταξη:</strong>
Η λειτουργία του προγράμματος είναι εξαιρετικά απλή. Αρκεί στη
γραμμή εντολών ο χρήστης να πληκτρολογήσει <em>dbdestroy dbName</em>
και το πρόγραμμα διαγράφει τη βάση δεδομένων με όνομα <em>dbName</em>.
</p>

<p><strong>Πληροφορίες υλοποίησης:</strong>
Κάθε βάση αποτελείται από ένα σύνολο από σχέσεις και ευρετήρια.
Τα αρχεία αυτά τοποθετούνται μέσα σε ένα φάκελο που έχει το ίδιο όνομα
με την βάση. Επομένως, η διαγραφή μιας βάσης με όνομα <em>dbName</em>,
ισοδυναμεί με την διαγραφή του φακέλου αυτού. </p>

<p>Για την διαγραφή φακέλων, δεν έχει γίνει καμία πρόβλεψη από το 
πρότυπο της C. Για αυτό τον λόγο θα πρέπει να χρησιμοποιήσετε την
εντολή <em>rm</em> του κελύφους. Για παράδειγμα, για να διαγράψετε τον
φάκελο <em>foo</em>, θα πρέπει να χρησιμοποιήσετε την εντολή
<em>system(&quot;rm -r foo&quot;). </em>Προσοχή: Αν προγραμματίζετε
σε περιβάλλον Ms-Windows, θα πρέπει να χρησιμοποιήσετε τις αντίστοιχες
εντολές <em>system(&quot;del</em> /<em>q foo&quot;) </em>και
<em>system(&quot;rmdir foo&quot;).</em></p>

<p>Σε γενικές γραμμές, η συνάρτηση <em>main()</em> του <em>dbdestroy</em>
θα έχει την ακόλουθη μορφή:</dt>

<pre>int main(int argc, char* argv[]){
        char command[80];
        char* dbname;

        if(argc!=2){
                printf(&quot;Χρήση: %s dbdestroy \n&quot;,argv[0]);
                return(1);
        }
</pre>

<pre>
        dbname=argv[1];
        sprintf(command,&quot;rm -r %s&quot;,dbname);
        system(command);

        return 0;
}</pre>

<h3>3 - minirel</h3>

Το πρόγραμμα <em>minirel</em> χρησιμοποιείται για την διαχείριση των
δεδομένων (πχ. δημιουργία σχέσεων) που υπάρχουν σε μία βάση.

<p><strong>Σύνταξη:</strong>
Η λειτουργία του προγράμματος είναι εξαιρετικά απλή. Το πρόγραμμα
αρχίζει την εκτέλεσή του όταν ο χρήστης πληκτρολογήσει <em>minirel
dbName</em> στο κέλυφος του λειτουργικού συστήματος.
<em>dbName</em> είναι το όνομα της βάσης που θέλει ο χρήστης να
χρησιμοποιήσει. Στην συνέχεια το πρόγραμμα εκτελεί τις εντολές που ο
χρήστης δίνει από το πληκτρολόγιο.  Η εκτέλεση του προγράμματος
τερματίζεται όταν ο χρήστης πληκτρολογήσει <em>quit</em>.
Οι εντολές που μπορεί να δώσει ο χρήστης είναι οι εξής (τα τμήματα
που είναι μέσα σε [] είναι προαιρετικά):</p>

<p><u><em>Α) Βοηθητικές εντολές:</em></u></p>

<p><b>1) <a name="CREATE">CREATE</a> relname (attr1=format1, ... , attrN=formatN);</b></p>
<blockquote>
<p>Η εντολή αυτή δημιουργεί μία νέα σχέση με όνομα relname. Η σχέση
αυτή έχει N γνωρίσματα με ονόματα attr1, attr2, ... attrN. Ο τύπος
(format) του κάθε γνωρίσματος μπορεί να είναι 'i', 'f' ή 'cXXX' όπου
ΧΧΧ είναι ένας αριθμός. Εάν το format είναι 'i' ή 'f', τότε το
αντίστοιχο γνώρισμα είναι ακέραιος ή πραγματικός αριθμός.
Αν το format είναι 'cXXX' τότε το αντίστοιχο γνώρισμα είναι κείμενο
μήκους XXX χαρακτήρων.</p>
</blockquote>

<p><b>2) <a name="BUILDINDEX">BUILDINDEX</a> relname(attrName);</b></p>
<blockquote>
<p>Η εντολή αυτή δημιουργεί ένα ευρετήριο για τη σχέση relName, με
βάση το γνώρισμα attrName. </p>
</blockquote>

<p><b>3) <a name="DESTROY">DESTROY</a> relname;</b></p>
<blockquote>
<p>Η εντολή αυτή διαγράφει τη σχέση με όνομα relname. Επιπλέον,
διαγράφει και τα τυχόν ευρετήρια που σχετίζονται με αυτή τη σχέση.</p>
</blockquote>

<p><b>4) <a name="QUIT">QUIT</a>;</b></p>
<blockquote>
<p>Η εντολή αυτή προκαλεί τον τερματισμό του προγράμματος
<em>minirel</em>.</p>
</blockquote>

<p><u><em>Β) Εντολές χειρισμού δεδομένων:</em></u></p>

<p><b>1) <a name="SELECT">SELECT </a>[INTO relname] &lt;TARGET_LIST&gt; [WHERE &lt;CONDITION&gt;]</b></p>

<blockquote>
<p>Η εντολή αυτή τυπώνει το αποτέλεσμα ενός ερωτήματος, ή προαιρετικά
εισάγει το αποτέλεσμα αυτό σε μία καινούργια σχέση με όνομα relname.
Εάν λείπει το τμήμα [WHERE &lt;CONDITION&gt;] της εντολής, τότε
ανασύρονται όλες οι εγγραφές της σχέσης που δηλώνει το TARGET_LIST.
<br>

Το TARGET_LIST έχει τη μορφή
(relname1.attr1, relname2.attr2,... ,relnameN.attrN).
To TARGET_LIST καθορίζει ποια γνωρίσματα πρέπει να περιληφθούν στην
απάντηση της εντολής SELECT. Όλα τα γνωρίσματα πρέπει να προέρχονται
από την ίδια σχέση, εκτός και αν το CONDITION υποδηλώνει ζεύξη
σχέσεων, στην οποία περίπτωση, τα γνωρίσματα μπορούν να ανήκουν σε
οποιαδήποτε από τις δύο σχέσεις της ζεύξης. Επομένως, αν το
ερώτημα δεν περιέχει ζεύξη, τότε όλα τα relnameX είναι ίδια, ενώ στην
αντίθετη περίπτωση, καθένα από τα relnameX αντιστοιχεί σε ένα από
τα δύο ονόματα των σχέσεων που συμμετέχουν στη ζεύξη.<br>
<br>

Σε ό,τι αφορά το CONDITION, αυτό έχει τη γενική μορφή<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;relname.attr &lt;OP&gt; value,<br>
αν το ερώτημα είναι επιλογής, ή τη μορφή<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;relname1.attr1 &lt;OP&gt; relname2.attr2,<br>
αν το ερώτημα είναι ζεύξης, ή τη μορφή<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;relname1.attr &lt;OP1&gt; value AND relname1.attr1 &lt;OP2&gt; relname2.attr2,<br>
αν το ερώτημα είναι επιλεκτικής ζεύξης.
Σε όλες τις περιπτώσεις, οι τελεστές OP,OP1,OP2 μπορούν να είναι '=', '&lt;',
'&lt;=', '&gt;', '&gt;=' ή '!='. Στην περίπτωση που το ερώτημα είναι
ερώτημα επιλογής, τότε το value είναι μία σταθερή τιμή όπως για
παράδειγμα -5, 6.7, &quot;foo&quot; κλπ.  Σε αυτήν την περίπτωση,
η έννοια της ερώτησης είναι να επιλεχθούν όλες οι εγγραφές που
ικανοποιούν τη συνθήκη.  Αντίστοιχα, αν το ερώτημα είναι τύπου
ζεύξης, τότε πρέπει να ανασυρθούν όλες οι εγγραφές και από τις δύο
σχέσεις που πληρούν τη συνθήκη της ζεύξης.
Τέλος, αν το ερώτημα είναι τύπου επιλεκτικής ζεύξης, οι εγγραφές στο
αποτέλεσμα πρέπει να ικανοποιούν και τις δύο συνθήκες.
</p>
</blockquote>

<p><b>2) <a name="DELETE">DELETE</a> relname [WHERE attr &lt;OP&gt; value]</b></p>
<blockquote>

<p>Η εντολή αυτή διαγράφει όλες τις εγγραφές της σχέσης με όνομα
relname οι οποίες ικανοποιούν το δοθέν κριτήριο.  Αν η εντολή δεν έχει
τμήμα WHERE, τότε όλες οι εγγραφές της σχέσης πρέπει να διαγραφούν.
</blockquote>

<p><b>3) <a name="INSERT">INSERT</a> relname (attr1=value1, attr2=value2, ..., attrN=valueN)</b></p>
<blockquote>
<p>Η εντολή αυτή εισάγει μία εγγραφή στη σχέση με όνομα relname.
Η σειρά με την οποία δίνονται τα γνωρίσματα είναι τυχαία, όμως σε
όλα τα γνωρίσματα της σχέσης πρέπει να ανατίθεται τιμή.</p>
</blockquote>

<p><strong>Πληροφορίες υλοποίησης:</strong>
Μέσα στην παρεχόμενη βιβλιοθήκη, υπάρχει μια συνάρτηση με όνομα
<em>yyparse</em>. Η ρουτίνα αυτή αναλαμβάνει να
χειριστεί την εισαγωγή των εντολών και την κλήση των κατάλληλων
συναρτήσεων (τις οποίες θα υλοποιήσετε εσείς) που υλοποιούν τις εντολές αυτές. Για παράδειγμα, αν ο χρήστης πληκτρολογήσει την εντολή
<em>DESTROY foo</em> τότε η συνάρτηση
<em>yyparse</em> αυτόματα θα καλέσει την συνάρτηση
<em>UT_destroy(...)</em> η οποία θα πρέπει να
διαγράψει τη σχέση <em>foo</em>.
Επομένως, η εργασία σας για την υλοποίηση του προγράμματος
<em>minirel</em> περιορίζεται στην υλοποίηση αυτών των συναρτήσεων που
καλούνται αυτόματα από την <em>yyparse</em>.

<p>Σε γενικές γραμμές, η συνάρτηση main του <em>minirel</em> θα έχει την
εξής μορφή:</p>

<pre>
int main(int argc, char* argv[]){
char command[80];
char* dbname;

if(argc!=2){
     printf(&quot;Χρήση: %s minirel \n&quot;,argv[0]);
     return(1);
}
dbname=argv[1];

/* Αρχικοποίηση προγράμματος      */
/* και άνοιγμα σχέσεων καταλόγου  */
.
.
.

/* Κλήση της συνάρτησης yyparse ή οποία  */
/* θα καλεί αυτόματα τις συναρτήσεις σας */
yyparse();

/* Κλείσιμο προγράμματος και           */
/* κλείσιμο των σχέσεων καταλόγου αν    */
/* ο χρήστης δεν πληκτρολόγησε την     */
/* εντολή QUIT                         */
.
.
.
return(0);
}

</pre>

<hr>

<h2><img src="../images/ball-t.gif">Συμβολομεταφραστής</h2>

<p>Μέσα στην παρεχόμενη βιβλιοθήκη, υπάρχει μια συνάρτηση με το όνομα
<em>yyparse</em> η οποία δεν δέχεται και δεν επιστρέφει κανένα όρισμα
(ορίζεται στο <a href="parser.tab.h">parser.tab.h</a>):</p>

<blockquote>
    <pre>void yyparse(void)</pre>
</blockquote>

<p>Η ρουτίνα αυτή αναλαμβάνει να χειριστεί την εισαγωγή των εντολών στο
πρόγραμμα <em>minirel</em> και την κλήση των κατάλληλων συναρτήσεων 
(τις οποίες θα υλοποιήσετε εσείς) που υλοποιούν της εντολές αυτές.
Για παράδειγμα, αν ο χρήστης πληκτρολογήσει στο <em>minirel</em> την
εντολή <em>DESTROY foo</em> τότε η
συνάρτηση <em>yyparse</em> αυτόματα θα καλέσει την συνάρτηση
<em>UT_destroy</em> η οποία θα πρέπει να
διαγράψει τη σχέση <em>foo</em>.  Επομένως, η εργασία σας για την
υλοποίηση του προγράμματος <em>minirel</em> περιορίζεται στην υλοποίηση
αυτών των συναρτήσεων που καλούνται αυτόματα από την <em>yyparse</em>.
</p>

<p>Οι περισσότερες συναρτήσεις που καλεί η <em>yyparse</em> (ορίζονται
στην επόμενη ενότητα) δέχονται δύο ορίσματα, το <em>argc</em> και το
<em>argv</em>.  To <em>argv</em> είναι ένας πίνακας με <em>argc</em>+1
στοιχεία. Τα στοιχεία αυτά είναι δείκτες σε κείμενο (δηλ.
<em>char*</em>). Κατά σύμβαση, το πρώτο στοιχείο του <em>argv</em> είναι
το όνομα της εντολής που πρέπει να εκτελεσθεί, ενώ το τελευταίο στοιχείο
είναι NULL.
Ο πίνακας <em>argv</em> έχει όλα τα απαιτούμενα στοιχεία που χρειάζεται
κάποιος για να καταλάβει τι πρέπει να κάνει η εντολή. Η χρήση του πίνακα
είναι υποχρεωτική καθώς ο αριθμός των παραμέτρων δεν είναι σταθερός.
</p>

<hr>

<h2><img src="../images/ball-t.gif">Περιγραφή συναρτήσεων</h2>

<p>Για την υλοποίηση αυτών των προγραμμάτων θα πρέπει να
χρησιμοποιήσετε ένα σύνολο από συναρτήσεις, οι οποίες και θα καλούν
τις συναρτήσεις που έχετε ήδη φτιάξει στα κατώτερα επίπεδα για το
χειρισμό εγγραφών ενός πίνακα και δευτερευόντων ευρετηρίων πίνακα.

<p>Οι συναρτήσεις που απαιτούνται σε αυτό το επίπεδο υλοποιούν την
<em>ΕΚΤΕΛΕΣΗ</em> των εντολών που υποστηρίζει το <em>minirel</em>.
Οι βοηθητικές συναρτήσεις δεδομένων υλοποιούν
τις εντολές <em>CREATE, BUILDINDEX, DESTROY,</em> και <em>QUIT</em>.
Οι συναρτήσεις χειρισμού δεδομένων υλοποιούν
τις εντολές <em>SELECT, INSERT,</em> και <em>DELETE</em>.
Οι συναρτήσεις του ενδιάμεσου αυτού επιπέδου δουλεύουν σε επίπεδο
εγγραφών και ευρετηρίων, παρέχοντας στον συμβολομεταφραστή ολοκληρωμένες
λειτουργίες (π.χ., δημιουργία μίας σχέσης).

<p>
Μία σημαντική λειτουργία που υλοποιείται στο ενδιάμεσο επίπεδο είναι
οι υπηρεσίες καταλόγου της βάσης. Δεν εμφανίζονται στο παραπάνω
σχήμα γιατί δεν παρέχεται αντίστοιχη διεπαφή προγραμματισμού προς το
ανώτερο επίπεδο. Αντίθετα, οι υπηρεσίες καταλόγου χρησιμοποιούνται
εσωτερικά από τις δύο κατηγορίες συναρτήσεων δεδομένων.</p>

<p>Σε υψηλό επίπεδο, ο συμβολομεταφραστής
αναλαμβάνει την μετατροπή των εντολών από απλό κείμενο σε μία
εσωτερική δομημένη μορφή και την κλήση των κατάλληλων συναρτήσεων
(του ενδιάμεσου επιπέδου) ώστε τελικά να εκτελεστούν οι εντολές
που ο χρήστης δίνει στο σύστημα.
Ο συμβολομεταφραστής έχει και αυτός υλοποιηθεί και θα σας δοθεί.
</p>

<h3><u>Βοηθητικές συναρτήσεις δεδομένων</u></h3>

<p>Οι βοηθητικές συναρτήσεις δεδομένων υλοποιούν εντολές όπως
η δημιουργία και καταστροφή σχέσεων, η παροχή πληροφοριών για
τους καταλόγους της βάσης, κλπ.  Πρόκειται για συναρτήσεις οι
οποίες καλούνται απευθείας από τον συμβολομεταφραστή, ανάλογα με τις
εντολές που εισάγει ο χρήστης.
Ειδικότερα οι βοηθητικές συναρτήσεις δεδομένων είναι οι εξής:</p>

<h3>UT_create()</h3>

<pre>int <a name="UT_create">UT_create</a>(int argc, char* argv[])
	argv[0]=&quot;create&quot;
	argv[1]=όνομα-σχέσης
	argv[2]=όνομα-πεδίου-1
	argv[3]=φορμάτ-πεδίου-1
	.
	.
	.
	argv[argc-2]=όνομα-πεδίου-Ν
	argv[argc-1]=φορμάτ-πεδίου-Ν
	argv[argc]=NULL</pre>

<p>Η συνάρτηση αυτή καλείται από την <em>yyparse</em> όταν ο χρήστης
πληκτρολογήσει μια εντολή <em>CREATE</em>.
Για τη δημιουργία της νέας σχέσης, η υλοποίησή σας θα πρέπει να
χρησιμοποιεί την συνάρτηση <em>HF_CreateFile</em>.
Επιπλέον θα πρέπει να ενημερώνει τους καταλόγους (σχέσεις
<em>relCat</em> και <em>attrCat</em>, κλπ) της βάσης. Δηλαδή, θα πρέπει
να εισάγει μία εγγραφή στη σχέση <em>relCat</em>, η οποία να περιγράφει
τα χαρακτηριστικά της νέας σχέσης.
Επιπρόσθετα, θα πρέπει να εισάγει στη σχέση <em>attrCat</em> τις
αντίστοιχες εγγραφές που θα περιγράφουν ένα-ένα τα γνωρίσματα της νέας
σχέσης.</p>

<h3>UT_buildindex()</h3>

<pre>int <a name="UT_buildindex">UT_buildindex</a>(int argc, char* argv[])
	argv[0]=&quot;buildindex&quot;
	argv[1]=όνομα-σχέσης
	argv[2]=όνομα-πεδίου
	argv[3]=NULL</pre>

<p>Η συνάρτηση αυτή καλείται από την <em>yyparse</em> όταν ο χρήστης
πληκτρολογήσει μια εντολή <em>BUILDINDEX</em>.
Η υλοποίηση της εντολής αυτής θα πρέπει να δημιουργεί το ευρετήριο
χρησιμοποιώντας την συνάρτηση <em>AM_CreateIndex</em>
και να ενημερώνει κατάλληλα τους καταλόγους της βάσης.</p>

<h3>UT_destroy()</h3>

<pre>int <a name="UT_destroy">UT_destroy</a>(int argc, char* argv[])
	argv[0]=&quot;destroy&quot;
	argv[1]=όνομα-σχέσης
	argv[2]=NULL</pre>

<p>Η συνάρτηση αυτή καλείται από την <em>yyparse</em> όταν ο χρήστης
πληκτρολογήσει μια εντολή <em>DESTROY</em>.
Για την υλοποίηση αυτής της εντολής θα πρέπει να χρησιμοποιήσετε τις
συναρτήσεις <em>AM_DestroyIndex</em> και <em>HF_DestroyFile</em>
και να ενημερώσετε κατάλληλα τους καταλόγους της βάσης.</p>

<h3>UT_quit()</h3>

<pre>int <a name="UT_quit">UT_quit</a>(void)</pre>

<p>Η συνάρτηση αυτή καλείται από την <em>yyparse</em> όταν ο χρήστης
πληκτρολογήσει την εντολή <em>QUIT</em>.
Η συνάρτηση αυτή θα πρέπει να κλείνει όλες τις τυχόν ανοικτές σχέσεις
και ευρετήρια (συμπεριλαμβανομένων και αυτών που αποτελούν τους
καταλόγους της βάσης) και στην συνέχεια να καλεί την <em>exit(1)</em>.
</p>


<h3>Συναρτήσεις χειρισμού δεδομένων</h3>

<p>Οι Συναρτήσεις χειρισμού δεδομένων υλοποιούν τις εντολές του
<em>minirel</em> που κάνουν εισαγωγή, διαγραφή και επιλογή εγγραφών από
σχέσεις. Πρόκειται για συναρτήσεις οι οποίες καλούνται απευθείας από
τον συμβολομεταφραστή, ανάλογα με τις εντολές που εισάγει ο χρήστης.
Ειδικότερα οι συναρτήσεις χειρισμού δεδομένων είναι οι εξής:</p>

<h3>DM_select()</h3>

<pre>int <a name="DM_select">DM_select</a>(int argc, char* argv[])
	argv[0]=&quot;select&quot;
	argv[1]=όνομα-σχέσης-αποτελέσματος /* Προαιρετικό στοιχείο */
	argv[2]=πλήθος-γνωρισμάτων-τα-οποία-προβάλλονται /* ακέραιος */
	argv[3]=όνομα-προβαλλόμενης-σχέσης-1
	argv[4]=όνομα-προβαλλόμενου-πεδίου-1
	.
	.
	.
	argv[argc-6]=όνομα-προβαλλόμενης-σχέσης-Ν
	argv[argc-5]=όνομα-προβαλλόμενου-πεδίου-Ν
	argv[argc-4]=όνομα-σχέσης-επιλογής  /*   Τα στοιχεία  */
	argv[argc-3]=όνομα-πεδίου-επιλογής  /*      αυτά      */
	argv[argc-2]=τελεστής               /*      είναι     */
	argv[argc-1]=τιμή                   /*   προαιρετικά  */
	argv[argc]=NULL</pre>

<p>Η συνάρτηση αυτή καλείται από την <em>yyparse</em> όταν ο χρήστης
πληκτρολογήσει μια εντολή <em>SELECT</em> η
οποία να μην είναι τύπου ζεύξης. Σε ό,τι αφορά την υλοποίηση
της εντολής αυτής, παρατηρήστε ότι όταν ζητείται να τυπωθούν τα
αποτελέσματα στην οθόνη, μπορείτε να εισάγετε τα αποτελέσματα σε μία
προσωρινή σχέση, στην συνέχεια να τυπώσετε τα περιεχόμενα της σχέσης
αυτής και τέλος να την καταστρέψετε. Επομένως, μπορείτε να
χειρισθείτε την περίπτωση που τα αποτελέσματα πρέπει να εισαχθούν
σε μία σχέση ως μια ειδίκευση της περίπτωσης που τα αποτελέσματα
πρέπει απλά να τυπωθούν.

<p>
Καθώς θα σαρώνετε τις εγγραφές για να επιλέξετε αυτές που ικανοποιούν
το κριτήριο της επιλογής (αν βέβαια υπάρχει), θα πρέπει ταυτόχρονα να
κάνετε και τον περιορισμό πάνω στα γνωρίσματα που τελικά θα υπάρχουν
στην απάντηση της ερώτησης. Δεν πρέπει να κάνετε πρώτα την επιλογή
των εγγραφών και στην συνέχεια να κάνετε τον περιορισμό πάνω στα
γνωρίσματα που υπάρχουν στην εντολή.

<p>
Αν υπάρχει ευρετήριο πάνω στο <em>όνομα-πεδίου-επιλογής</em> τότε θα
πρέπει <em>υποχρεωτικά</em> να το χρησιμοποιήσετε εφόσον ο <em>τελεστής</em>
υποστηρίζεται από τον τύπο του ευρετηρίου.

<p>
Τέλος, προσοχή θέλει το γεγονός ότι το στοιχείο <em>τιμή</em> (όπως
επίσης και το στοιχείο <em>τελεστής</em>) είναι δείκτης σε κείμενο,
δηλαδή θα πρέπει εσείς να κάνετε την μετατροπή στον σωστό τύπο.

<h3>DM_join()</h3>

<pre>int <a name="DM_join">DM_join</a>(int argc, char* argv[])
	argv[0]=&quot;join&quot;
	argv[1]=όνομα-σχέσης-αποτελέσματος /* Προαιρετικό στοιχείο */
	argv[2]=πλήθος-γνωρισμάτων-τα-οποία-προβάλλονται /* ακέραιος */
	argv[3]=όνομα-προβαλλόμενης-σχέσης-1
	argv[4]=όνομα-προβαλλόμενου-πεδίου-1
	.
	.
	.
	argv[argc-7]=όνομα-προβαλλόμενης-σχέσης-Ν
	argv[argc-6]=όνομα-προβαλλόμενου-πεδίου-Ν
	argv[argc-5]=όνομα-σχέσης-ζεύξης-1
	argv[argc-4]=όνομα-πεδίου-ζεύξης-1
	argv[argc-3]=τελεστής
	argv[argc-2]=όνομα-σχέσης-ζεύξης-2
	argv[argc-1]=όνομα-πεδίου-ζεύξης-2
	argv[argc]=NULL</pre>

<p>Η συνάρτηση αυτή καλείται από την <em>yyparse</em> όταν ο χρήστης
πληκτρολογήσει μια εντολή <em>SELECT</em> η οποία είναι τύπου ζεύξης.
Για την υλοποίηση της συνάρτησης αυτής ισχύουν οι ίδιες παρατηρήσεις
που δίνονται και για την συνάρτηση <em>DM_select</em>.
Επιπλέον, για τη ζεύξη θα πρέπει να χρησιμοποιηθεί ο
αλγόριθμος εμφωλιασμένων βρόχων. Αν υπάρχει ευρετήριο σε κάποιο από
τα γνωρίσματα ζεύξης θα πρέπει επίσης <em>υποχρεωτικά</em>
να χρησιμοποιηθεί εφόσον ο <em>τελεστής</em> υποστηρίζεται από τον 
τύπο του ευρετηρίου.</p>

<h3>DM_selectivejoin()</h3>

<pre>int <a name="DM_selectivejoin">DM_selectivejoin</a>(int argc, char* argv[])
	argv[0]=&quot;selectivejoin&quot;
	argv[1]=όνομα-σχέσης-αποτελέσματος /* Προαιρετικό στοιχείο */
	argv[2]=πλήθος-γνωρισμάτων-τα-οποία-προβάλλονται /* ακέραιος */
	argv[3]=όνομα-προβαλλόμενης-σχέσης-1
	argv[4]=όνομα-προβαλλόμενου-πεδίου-1
	.
	.
	.
	argv[argc-11]=όνομα-προβαλλόμενης-σχέσης-Ν
	argv[argc-10]=όνομα-προβαλλόμενου-πεδίου-Ν
	argv[argc-9]=όνομα-σχέσης-επιλογής
	argv[argc-8]=όνομα-πεδίου-επιλογής
	argv[argc-7]=τελεστής επιλογής
	argv[argc-6]=τιμή
	argv[argc-5]=όνομα-σχέσης-ζεύξης-1 /* ίδιο με argv[argc-9] */
	argv[argc-4]=όνομα-πεδίου-ζεύξης-1
	argv[argc-3]=τελεστής ζεύξης
	argv[argc-2]=όνομα-σχέσης-ζεύξης-2
	argv[argc-1]=όνομα-πεδίου-ζεύξης-2
	argv[argc]=NULL</pre>

<p>Η συνάρτηση αυτή καλείται από την <em>yyparse</em> όταν ο χρήστης
πληκτρολογήσει μια εντολή <em>SELECT</em> η οποία είναι τύπου
επιλεκτικής ζεύξης.
Για την υλοποίηση της συνάρτησης αυτής ισχύουν όλες οι παρατηρήσεις
που δίνονται και για τις συναρτήσεις <em>DM_select</em> και
<em>DM_join</em> (π.χ., εμφωλιασμένοι βρόχοι, υποχρεωτική χρήση
ευρετηρίων αν υπάρχουν και είναι χρήσιμα, κτλ.).
Επιπλέον, με βάση μια εκτίμηση κόστους, θα πρέπει να επιλέξει το ποιά
σχέση θα είναι εσωτερική και ποιά εξωτερική. Αν επιλεγεί η σχέση
επιλογής ως εξωτερική, τότε η συνάρτηση θα πρέπει να καλέσει την
<em>DM_pipeline</em> για την εκτέλεση της επιλεκτικής ζεύξης.
Αντίθετα, αν επιλεγεί η άλλη σχέση ως εξωτερική, τότε η συνάρτηση θα
πρέπει να καλέσει την <em>DM_select</em> για να δημιουργήσει μια
προσωρινή σχέση με το αποτέλεσμα της επιλογής και μετά θα καλέσει την
<em>DM_join</em> για την ζεύξη της εξωτερικής σχέσης με την προσωρινή
αυτή σχέση.</p>

<h3>DM_pipeline()</h3>

<pre>int <a name="DM_pipeline">DM_pipeline</a>(int argc, char* argv[])
	argv[0]=&quot;pipeline&quot;
	argv[1]=όνομα-σχέσης-αποτελέσματος /* Προαιρετικό στοιχείο */
	argv[2]=πλήθος-γνωρισμάτων-τα-οποία-προβάλλονται /* ακέραιος */
	argv[3]=όνομα-προβαλλόμενης-σχέσης-1
	argv[4]=όνομα-προβαλλόμενου-πεδίου-1
	.
	.
	.
	argv[argc-11]=όνομα-προβαλλόμενης-σχέσης-Ν
	argv[argc-10]=όνομα-προβαλλόμενου-πεδίου-Ν
	argv[argc-9]=όνομα-σχέσης-επιλογής
	argv[argc-8]=όνομα-πεδίου-επιλογής
	argv[argc-7]=τελεστής επιλογής
	argv[argc-6]=τιμή
	argv[argc-5]=όνομα-σχέσης-ζεύξης-1 /* ίδιο με argv[argc-9] */
	argv[argc-4]=όνομα-πεδίου-ζεύξης-1
	argv[argc-3]=τελεστής ζεύξης
	argv[argc-2]=όνομα-σχέσης-ζεύξης-2
	argv[argc-1]=όνομα-πεδίου-ζεύξης-2
	argv[argc]=NULL</pre>


<p>Η συνάρτηση αυτή καλείται από την <em>DM_selectivejoin</em> όταν
αποφασίζει ότι η σχέση της επιλογής θα χρησιμοποιηθεί ως εξωτερική για
τους εμφωλιασμένους βρόχους που θα υλοποιήσουν τη ζεύξη.
Στην περίπτωση αυτή, η συνάρτηση θα σαρώνει την εξωτερική σχέση, θα
εφαρμόζει την επιλογή, και μόνο για τις εγγραφές που την ικανοποιούν 
θα προχωρά στην σάρωση της εσωτερικής σχέσης και τον έλεγχο της συνθήκης
της ζεύξης. Επιπλέον, αν δε χρησιμοποιείται ευρετήριο για την εσωτερική
σχέση, η εσωτερική σάρωση θα πραγματοποιείται μια φορά για κάθε ομάδα
από εγγραφές της εξωτερικής σχέσης που ικανοποιούν την επιλογή και
γεμίζουν ένα μπλοκ.

<h3>DM_delete()</h3>

<pre>int <a name="DM_delete">DM_delete</a>(int argc, char* argv[])
	argv[0]=&quot;delete&quot;
	argv[1]=όνομα-σχέσης
	argv[argc-3]=όνομα-πεδίου         /*   Τα στοιχεία  */
	argv[argc-2]=τελεστής             /*    αυτά είναι  */
	argv[argc-1]=τιμή                 /*   προαιρετικά  */
	argv[argc]=NULL</pre>

<p>Η συνάρτηση αυτή καλείται από την <em>yyparse</em> όταν ο χρήστης
πληκτρολογήσει μια εντολή <em>DELETE</em>.
Για την υλοποίησή της θα πρέπει να χρησιμοποιήσετε τις συναρτήσεις
<em>AM_DeleteEntry</em> και <em>ΗF_DeleteRec</em>.
Αν υπάρχει ευρετήριο στο γνώρισμα που χρησιμοποιείται για την επιλογή
των εγγραφών θα πρέπει <em>υποχρεωτικά</em> να χρησιμοποιηθεί εφόσον ο 
<em>τελεστής</em> υποστηρίζεται από τον τύπο του ευρετηρίου.</p>

<h3>DM_insert()</h3>

<pre>int <a name="DM_insert">DM_insert</a>(int argc, char* argv[])
	argv[0]=&quot;insert&quot;
	argv[1]=όνομα-σχέσης
	argv[2]=όνομα-πεδίου-1
	argv[3]=τιμή-1
	argv[4]=όνομα-πεδίου-2
	argv[5]=τιμή-2
	.
	.
	.
	argv[argc]=NULL</pre>

<p>Η συνάρτηση αυτή καλείται από την <em>yyparse</em> όταν ο χρήστης
πληκτρολογήσει μια εντολή <em>INSERT</em>.
Για την υλοποίησή της θα πρέπει να χρησιμοποιήσετε τις συναρτήσεις
<em>AM_InsertEntry</em> και <em>ΗF_InsertRec</em>. </p>

<hr>

<h2><img src="../images/ball-t.gif">Κατάλογοι</h2>

<p>
Ένα από τα ωραία πράγματα των σχεσιακών συστημάτων βάσεων δεδομένων
είναι ότι η εσωτερική πληροφορία που κρατούν για το σχήμα κάθε βάσης
(τους πίνακες, τα πεδία τους, τα ευρετήριά τους, κτλ.) διατηρείται
και αυτή σε πίνακες.  Οι πίνακες αυτοί ανήκουν στο ίδιο το σύστημα
και λέγονται <em>κατάλογοι</em>.

<p>
Υπάρχουν πάντα δύο βασικοί κατάλογοι: <em>relCat</em> και
<em>attrCat</em>.  Και οι δύο αυτοί πίνακες δημιουργούνται όταν η εντολή
<em>dbcreate dbname</em> εκτελείται. Μπαίνουν στο φάκελο <em>dbname</em>
που δημιουργείται, καθότι κάθε βάση έχει το δικό της σχήμα. Πρέπει να
 χρησιμοποιήσετε την <em>HF_CreateFile</em> για να δημιουργήσετε
τους δύο πίνακες ώστε να μπορείτε μετά να τους διαχειριστείτε με τις
κανονικές ρουτίνες που έχετε φτιάξει για τους υπόλοιπους πίνακες.
Για παράδειγμα, μπορείτε αν θέλετε να ορίσετε και ευρετήρια πάνω
σε κάποια πεδία των καταλόγων ώστε οι πρόσβαση σ' αυτούς να είναι
γρήγορη. Αυτό σημαίνει ότι το πρόγραμμα C που θα φτιάξετε για την
<em>dbcreate</em> πρέπει να μεταφραστεί μαζί με τα επίπεδα HF και AM.

<p>
Ο πίνακας <em>relCat</em> θα χρησιμοποιηθεί για να κρατά στοιχεία για
κάθε πίνακα μιας βάσης, συμπεριλαμβανομένων και όποιων στατιστικών
κρίνετε ότι χρειάζεστε για την επιλογή πλάνου εκτέλεσης κάποιων
τελεστών. Κάθε εγγραφή του πίνακα <em>relCat</em> θα πρέπει να έχει 
<u><strong>περίπου</strong></u> την εξής δομή αν την εκφράζαμε σε μορφή C:

<pre>typedef struct {
	char relname[MAXNAME];	/* όνομα πίνακα */
	int relwidth;		/* εύρος εγγραφής πίνακα σε bytes */
	int attrcnt;		/* αριθμός πεδίων εγγραφής */
	int indexcnt;		/* αριθμός ευρετηρίων πίνακα */
	int blockcnt;		/* αριθμός μπλοκ πίνακα */
	} relDesc; </pre>

Ο πίνακας <em>attrCat</em> θα χρησιμοποιηθεί για να κρατά στοιχεία για
κάθε πεδίο κάθε πίνακα μιας βάσης, συμπεριλαμβανομένων και πάλι των
απαραίτητων απλών στατιστικών. Κάθε εγγραφή του πίνακα <em>attrCat</em>
θα πρέπει να έχει <u><strong>περίπου</strong></u> την εξής δομή αν την εκφράζαμε σε
μορφή C:

<pre>typedef struct {
	char relname[MAXNAME];	/* όνομα πίνακα */
	char attrname[MAXNAME];	/* όνομα πεδίου του πίνακα */
	int offset;		/* απόσταση αρχής πεδίου από την αρχή της εγγραφής σε bytes */
	int attrlength;		/* μήκος πεδίου σε bytes */
	char attrtype;		/* τύπος πεδίου ('i', 'f', ή 'c' */
	int valuecnt;		/* αριθμός διαφορετικών τιμών πεδίου */
	int indexed;		/* TRUE αν το πεδίο έχει ευρετήριο */
	int indexno;		/* αύξων αριθμός του ευρετηρίου αν indexed=TRUE */
	} attrDesc; </pre>

<p>
<em>Παρατήρηση</em>: Όταν δημιουργείτε τους καταλόγους, να
χρησιμοιήσετε την συνάρτηση <em>sizeof</em> στις παραπάνω δομές για να
βρείτε το σωστό μήκος εγγραφής των καταλόγων.  Ο συμβολομετραφραστής
της C προσθέτει μερικές φορές χώρο σε δομές όπως οι παραπάνω για
να εγγυηθεί ότι τα δεδομένα θα ξεκινούν από όρια λέξεων στη μνήμη
του, οπότε αν δεν χρησιμοποιήσετε την <em>sizeof</em> ίσως προκύψουν
προβλήματα.

<p>
Τα παρακάτω παραδείγματα δείχνουν πώς πρέπει να χρησιμοποιούνται οι
κατάλογοι.  Όταν καλείται το <em>minirel</em> για πρώτη φορά, η παρακάτω
ακολουθία κλήσεων πρέπει να εκτελείται:

<pre>#define RELCAT "relCat"
     #define ATTRCAT "attrCat"

     relcatFileDesc = HF_OpenFile(RELCAT);
     if (relcatFileDesc < 0)
	{printf ("Error in opening relCat. Error = %d\n", relcatFileDesc); exit();}

     attrcatFileDesc = HF_OpenFile(ATTRCAT);
     if (attrcatFileDesc < 0)
	{printf ("Error in opening attrCat. Error = %d\n", attrcatFileDesc); exit();} </pre>

<p>
Αν όλα πάνε καλά, θα πρέπει να μείνουν αυτά τα αρχεία συνεχώς ανοιχτά
όσο το σύστημα είναι ενεργό.  Βεβαιωθείτε βέβαια ότι όταν υλοιποιείτε
την <em>quit</em>, ανάλογα καλείται και η <em>HF_CloseFile</em> σε κάθε
ένα από τα δύο παραπάνω αναγνωριστικά πριν κλείσει το σύστημα.

<p>
Η προσπέλαση στους καταλόγους είναι αναπόσπαστο κομμάτι σχεδόν όλων
των εντολών.  Κάθε φορά, θα πρέπει να επιλέγονται οι εγγραφές τους
που αντιστοιχούν στα ζητούμενα πεδία και στους ζητούμενους πίνακες
και να χρησιμοποιούντα τα στοιχεία τους στις κλήσεις των ρουτινών
των διαφόρων επιπέδων του κώδικα.
Μάλλον θα σας βοηθήσει να γράψετε μια συνάρτηση που να δέχεται ένα
όνομα πίνακα και ένα όνομα πεδίου του και επιστρέφει κάποια περιγραφή
του πεδίου - κάτι τέτοιο θα χρειαστείτε να το κάνετε πολλές φορές.

<hr>

<h2><img src="../images/ball-t.gif">Διαδικαστικές Λεπτομέρειες</h2>

Όλα τα διαδικαστικά θέματα καθώς και θέματα ελέγχου σφαλμάτων
παραμένουν όπως και στα προηγούμενα μέρη της εργασίας.
Το τί ακριβώς θα παραδόσετε, πού θα βρείτε τα αρχεία με τα οποία θα
ελέγξετε τελικά το πρόγραμμά σας, κτλ., θα ανακοινωθεί πολύ σύντομα.

<p>
Τα προγράμματά σας θα πρέπει να δουλεύουν στα μηχανήματα του τμήματος
(είτε στα sun (Unix) είτε στα pc (Windows)) ώστε να μπορούν να
ελεγχθούν.
Ακόμη και αν δουλέψετε σε δικούς σας υπολογιστές θα πρέπει να
βεβαιωθείτε ότι το τελικό αποτέλεσμα δουλεύει και εδώ τοπικά.
Η έκδοση της C που θα χρησιμοποιήσετε πρέπει να έχει ακέραιους των
4 bytes και να επιτρέπει αλλαγή ερμηνείας τύπου δεδομένων
(type casting).

<p>
Όλα τα μέρη της εργασίας αυτής θα υλοποιηθούν
από ομάδες των δύο ή τριών φοιτητών, οι οποίες εκτός σοβαρών
περιπτώσεων πρέπει να είναι οι ίδιες που παρέδωσαν και τα δύο πρώτα
μέρη της εργασίας.  Αν έχει υπάρξει η αλλαγή, ενημερώστε τον κo
Πανταζάρα.

</body>

</html>
